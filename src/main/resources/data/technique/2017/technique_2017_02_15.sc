Class 类的生命周期，是从被加载到虚拟机内存开始，到被卸载出内存。

<pre>
加载 Loading
1. 通过一个类的全限定名来获取定义此类的二进制字节流。
2. 将字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在堆中生成一个代表这个类的 java.lang.Class 对象，作为方法区这些数据的访问入口。
</pre>

<pre>
验证 Verification
1. 文件格式验证（例如是否 0xCAFEBABE 开头，版本号，常量池常量，索引值...）
2. 元数据验证（检查父类，继承类，抽象类的实现...）
3. 字节码验证（数据流和控制流分析。对类的方法体进行分析。）
4. 符号引用验证（引用是否可以找到对应的类，访问性是否可被访问...）
</pre>

<pre>
准备 Preparation
</pre>

<pre>
解析 Resolution
</pre>

<pre>
初始化 Initialization
遇到 new getstatic putstatic invokestatic 4条字节码指令。生成这4条指令的场景一般是，使用 new 关键字实力化对象，或 读取设置一个 static 定义的字段的类就会被初始化（被 final 修饰的字段，在编译期已经把结果放入常量池了）。另外，如果创建这个对象的数组时候，其实并不会初始化这个对象，而是生成一个继承 Object 的子类来代表这个对象的一维数组，所以只对这个子类进行初始化。
java.lang.reflect 进行反射调用。
初始化一个类时，如果其父类未被初始化，则需要先出发父类的初始化。
虚拟机启动时，会先初始化一个含有 main() 方法的主类。
</pre>

<pre>
使用  Using
</pre>

<pre>
卸载 Unloading
</pre>